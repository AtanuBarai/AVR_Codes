
Atmega8_Avi_gluco.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003b8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b4  00800060  000003b8  0000042c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .stab         000006cc  00000000  00000000  000004e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000085  00000000  00000000  00000bac  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000040  00000000  00000000  00000c31  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000000b9  00000000  00000000  00000c71  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000060a  00000000  00000000  00000d2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000342  00000000  00000000  00001334  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007f2  00000000  00000000  00001676  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000100  00000000  00000000  00001e68  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000226  00000000  00000000  00001f68  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004ba  00000000  00000000  0000218e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubtypes 00000063  00000000  00000000  00002648  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000026ab  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	24 c0       	rjmp	.+72     	; 0x4c <__bad_interrupt>
   4:	23 c0       	rjmp	.+70     	; 0x4c <__bad_interrupt>
   6:	22 c0       	rjmp	.+68     	; 0x4c <__bad_interrupt>
   8:	21 c0       	rjmp	.+66     	; 0x4c <__bad_interrupt>
   a:	20 c0       	rjmp	.+64     	; 0x4c <__bad_interrupt>
   c:	1f c0       	rjmp	.+62     	; 0x4c <__bad_interrupt>
   e:	1e c0       	rjmp	.+60     	; 0x4c <__bad_interrupt>
  10:	1d c0       	rjmp	.+58     	; 0x4c <__bad_interrupt>
  12:	1c c0       	rjmp	.+56     	; 0x4c <__bad_interrupt>
  14:	1b c0       	rjmp	.+54     	; 0x4c <__bad_interrupt>
  16:	1a c0       	rjmp	.+52     	; 0x4c <__bad_interrupt>
  18:	19 c0       	rjmp	.+50     	; 0x4c <__bad_interrupt>
  1a:	18 c0       	rjmp	.+48     	; 0x4c <__bad_interrupt>
  1c:	17 c0       	rjmp	.+46     	; 0x4c <__bad_interrupt>
  1e:	16 c0       	rjmp	.+44     	; 0x4c <__bad_interrupt>
  20:	15 c0       	rjmp	.+42     	; 0x4c <__bad_interrupt>
  22:	14 c0       	rjmp	.+40     	; 0x4c <__bad_interrupt>
  24:	13 c0       	rjmp	.+38     	; 0x4c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	11 e0       	ldi	r17, 0x01	; 1
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e8 eb       	ldi	r30, 0xB8	; 184
  3a:	f3 e0       	ldi	r31, 0x03	; 3
  3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0
  42:	a4 31       	cpi	r26, 0x14	; 20
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <__SP_H__>
  48:	02 d0       	rcall	.+4      	; 0x4e <main>
  4a:	b4 c1       	rjmp	.+872    	; 0x3b4 <_exit>

0000004c <__bad_interrupt>:
  4c:	d9 cf       	rjmp	.-78     	; 0x0 <__vectors>

0000004e <main>:
	
		
int  main(void)
	{
		unsigned  int adc_value;	// Variable to hold ADC  result
		DDRB=0xF7;	// Set Port B.0 for LED output
  4e:	87 ef       	ldi	r24, 0xF7	; 247
  50:	87 bb       	out	0x17, r24	; 23
		PORTB  = 0x00;	// Clear Portd pins
  52:	18 ba       	out	0x18, r1	; 24
		lcd_init(LCD_DISP_ON_CURSOR_BLINK);
  54:	8f e0       	ldi	r24, 0x0F	; 15
  56:	7c d1       	rcall	.+760    	; 0x350 <lcd_init>
 		ADCSRA  = (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1);
  58:	86 e8       	ldi	r24, 0x86	; 134
  5a:	86 b9       	out	0x06, r24	; 6
		// Set ADCSRA Register with division factor 64

		ADMUX=0x05;	//Binary equivalent of 0101
  5c:	85 e0       	ldi	r24, 0x05	; 5
  5e:	87 b9       	out	0x07, r24	; 7
			
		while (1)	//Forever since it is in  single conversion mode
		{
			while(PINB & 0x08);
  60:	b3 99       	sbic	0x16, 3	; 22
  62:	fe cf       	rjmp	.-4      	; 0x60 <main+0x12>
			lcd_clrscr();
  64:	3d d1       	rcall	.+634    	; 0x2e0 <lcd_clrscr>
			lcd_puts("Checking..");
  66:	80 e6       	ldi	r24, 0x60	; 96
  68:	90 e0       	ldi	r25, 0x00	; 0
  6a:	53 d1       	rcall	.+678    	; 0x312 <lcd_puts>
			lcd_gotoxy(0,1);
  6c:	80 e0       	ldi	r24, 0x00	; 0
  6e:	61 e0       	ldi	r22, 0x01	; 1
  70:	2c d1       	rcall	.+600    	; 0x2ca <lcd_gotoxy>
			lcd_puts("Please Wait");
  72:	8b e6       	ldi	r24, 0x6B	; 107
  74:	90 e0       	ldi	r25, 0x00	; 0
  76:	4d d1       	rcall	.+666    	; 0x312 <lcd_puts>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  78:	8f ef       	ldi	r24, 0xFF	; 255
  7a:	9b e7       	ldi	r25, 0x7B	; 123
  7c:	a2 e9       	ldi	r26, 0x92	; 146
  7e:	81 50       	subi	r24, 0x01	; 1
  80:	90 40       	sbci	r25, 0x00	; 0
  82:	a0 40       	sbci	r26, 0x00	; 0
  84:	e1 f7       	brne	.-8      	; 0x7e <main+0x30>
  86:	00 c0       	rjmp	.+0      	; 0x88 <main+0x3a>
  88:	00 00       	nop
			_delay_ms(6000);
  			ADCSRA  |= (1<<ADSC);	// Start conversion
  8a:	36 9a       	sbi	0x06, 6	; 6
			while (ADCSRA &  (1<<ADSC));
  8c:	36 99       	sbic	0x06, 6	; 6
  8e:	fe cf       	rjmp	.-4      	; 0x8c <main+0x3e>
			// wait until conversion  completes; ADSC=0 means Complete

  			adc_value = ADCW;	//Store ADC result
  90:	84 b1       	in	r24, 0x04	; 4
  92:	95 b1       	in	r25, 0x05	; 5
			  
			  if (adc_value < 2)
  94:	82 30       	cpi	r24, 0x02	; 2
  96:	91 05       	cpc	r25, r1
  98:	08 f4       	brcc	.+2      	; 0x9c <main+0x4e>
  9a:	89 c0       	rjmp	.+274    	; 0x1ae <main+0x160>
			  {
				  lcd_clrscr();
				  lcd_puts("65mg/dL");
			  }
			  else if (adc_value >= 2 && adc_value < 4)
  9c:	9c 01       	movw	r18, r24
  9e:	22 50       	subi	r18, 0x02	; 2
  a0:	30 40       	sbci	r19, 0x00	; 0
  a2:	22 30       	cpi	r18, 0x02	; 2
  a4:	31 05       	cpc	r19, r1
  a6:	08 f4       	brcc	.+2      	; 0xaa <main+0x5c>
  a8:	8c c0       	rjmp	.+280    	; 0x1c2 <main+0x174>
			  {
				  lcd_clrscr();
				  lcd_puts("67mg/dL");
			  }
			  else if (adc_value >= 4 && adc_value < 8)
  aa:	9c 01       	movw	r18, r24
  ac:	24 50       	subi	r18, 0x04	; 4
  ae:	30 40       	sbci	r19, 0x00	; 0
  b0:	24 30       	cpi	r18, 0x04	; 4
  b2:	31 05       	cpc	r19, r1
  b4:	08 f4       	brcc	.+2      	; 0xb8 <main+0x6a>
  b6:	6d c0       	rjmp	.+218    	; 0x192 <main+0x144>
			  {
				  lcd_clrscr();
				  lcd_puts("69mg/dL");
			  }
			  else if (adc_value >= 8 && adc_value < 16)
  b8:	9c 01       	movw	r18, r24
  ba:	28 50       	subi	r18, 0x08	; 8
  bc:	30 40       	sbci	r19, 0x00	; 0
  be:	28 30       	cpi	r18, 0x08	; 8
  c0:	31 05       	cpc	r19, r1
  c2:	08 f4       	brcc	.+2      	; 0xc6 <main+0x78>
  c4:	6d c0       	rjmp	.+218    	; 0x1a0 <main+0x152>
			  {
				  lcd_clrscr();
				  lcd_puts("72mg/dL");
			  }
			  else if (adc_value >= 16 && adc_value < 32)
  c6:	9c 01       	movw	r18, r24
  c8:	20 51       	subi	r18, 0x10	; 16
  ca:	30 40       	sbci	r19, 0x00	; 0
  cc:	20 31       	cpi	r18, 0x10	; 16
  ce:	31 05       	cpc	r19, r1
  d0:	08 f4       	brcc	.+2      	; 0xd4 <main+0x86>
  d2:	58 c0       	rjmp	.+176    	; 0x184 <main+0x136>
			  {
				  lcd_clrscr();
				  lcd_puts("78mg/dL");
			  }
			  else if (adc_value >= 32 && adc_value < 48)
  d4:	9c 01       	movw	r18, r24
  d6:	20 52       	subi	r18, 0x20	; 32
  d8:	30 40       	sbci	r19, 0x00	; 0
  da:	20 31       	cpi	r18, 0x10	; 16
  dc:	31 05       	cpc	r19, r1
  de:	08 f4       	brcc	.+2      	; 0xe2 <main+0x94>
  e0:	6b c0       	rjmp	.+214    	; 0x1b8 <main+0x16a>
			  {
				  lcd_clrscr();
				  lcd_puts("82mg/dL");
			  }
			  else if (adc_value >= 48 && adc_value < 64)
  e2:	9c 01       	movw	r18, r24
  e4:	20 53       	subi	r18, 0x30	; 48
  e6:	30 40       	sbci	r19, 0x00	; 0
  e8:	20 31       	cpi	r18, 0x10	; 16
  ea:	31 05       	cpc	r19, r1
  ec:	08 f4       	brcc	.+2      	; 0xf0 <main+0xa2>
  ee:	6e c0       	rjmp	.+220    	; 0x1cc <main+0x17e>
			  {
				  lcd_clrscr();
				  lcd_puts("87mg/dL");
			  }
			  
			  else if (adc_value >= 64 && adc_value < 90)
  f0:	9c 01       	movw	r18, r24
  f2:	20 54       	subi	r18, 0x40	; 64
  f4:	30 40       	sbci	r19, 0x00	; 0
  f6:	2a 31       	cpi	r18, 0x1A	; 26
  f8:	31 05       	cpc	r19, r1
  fa:	08 f4       	brcc	.+2      	; 0xfe <main+0xb0>
  fc:	6c c0       	rjmp	.+216    	; 0x1d6 <main+0x188>
			  {
				  lcd_clrscr();
				  lcd_puts("93mg/dL");
			  }
			  
			  else if (adc_value >= 90 && adc_value < 128)
  fe:	9c 01       	movw	r18, r24
 100:	2a 55       	subi	r18, 0x5A	; 90
 102:	30 40       	sbci	r19, 0x00	; 0
 104:	26 32       	cpi	r18, 0x26	; 38
 106:	31 05       	cpc	r19, r1
 108:	08 f4       	brcc	.+2      	; 0x10c <main+0xbe>
 10a:	6a c0       	rjmp	.+212    	; 0x1e0 <main+0x192>
			  {
				  lcd_clrscr();
				  lcd_puts("99mg/dL");
			  }
			  else if (adc_value >= 128 && adc_value < 150)
 10c:	9c 01       	movw	r18, r24
 10e:	20 58       	subi	r18, 0x80	; 128
 110:	30 40       	sbci	r19, 0x00	; 0
 112:	26 31       	cpi	r18, 0x16	; 22
 114:	31 05       	cpc	r19, r1
 116:	08 f4       	brcc	.+2      	; 0x11a <main+0xcc>
 118:	6d c0       	rjmp	.+218    	; 0x1f4 <main+0x1a6>
			  {
				  lcd_clrscr();
				  lcd_puts("107mg/dL");
			  }
			  
			  else if (adc_value >= 150 && adc_value < 180)
 11a:	9c 01       	movw	r18, r24
 11c:	26 59       	subi	r18, 0x96	; 150
 11e:	30 40       	sbci	r19, 0x00	; 0
 120:	2e 31       	cpi	r18, 0x1E	; 30
 122:	31 05       	cpc	r19, r1
 124:	08 f4       	brcc	.+2      	; 0x128 <main+0xda>
 126:	6b c0       	rjmp	.+214    	; 0x1fe <main+0x1b0>
			  {
				  lcd_clrscr();
				  lcd_puts("118mg/dL");
			  }
			  
			  else if (adc_value >= 180 && adc_value < 210)
 128:	9c 01       	movw	r18, r24
 12a:	24 5b       	subi	r18, 0xB4	; 180
 12c:	30 40       	sbci	r19, 0x00	; 0
 12e:	2e 31       	cpi	r18, 0x1E	; 30
 130:	31 05       	cpc	r19, r1
 132:	08 f4       	brcc	.+2      	; 0x136 <main+0xe8>
 134:	69 c0       	rjmp	.+210    	; 0x208 <main+0x1ba>
			  {
				  lcd_clrscr();
				  lcd_puts("135mg/dL");
			  }
			  
			  else if (adc_value >= 210 && adc_value < 240)
 136:	9c 01       	movw	r18, r24
 138:	22 5d       	subi	r18, 0xD2	; 210
 13a:	30 40       	sbci	r19, 0x00	; 0
 13c:	2e 31       	cpi	r18, 0x1E	; 30
 13e:	31 05       	cpc	r19, r1
 140:	08 f4       	brcc	.+2      	; 0x144 <main+0xf6>
 142:	67 c0       	rjmp	.+206    	; 0x212 <main+0x1c4>
			  {
				  lcd_clrscr();
				  lcd_puts("163mg/dL");
			  }
			  else if (adc_value >= 240 && adc_value < 280)
 144:	9c 01       	movw	r18, r24
 146:	20 5f       	subi	r18, 0xF0	; 240
 148:	30 40       	sbci	r19, 0x00	; 0
 14a:	28 32       	cpi	r18, 0x28	; 40
 14c:	31 05       	cpc	r19, r1
 14e:	08 f4       	brcc	.+2      	; 0x152 <main+0x104>
 150:	65 c0       	rjmp	.+202    	; 0x21c <main+0x1ce>
			  {
				  lcd_clrscr();
				  lcd_puts("182mg/dL");
			  }
			  else if (adc_value >= 280 && adc_value < 310)
 152:	9c 01       	movw	r18, r24
 154:	28 51       	subi	r18, 0x18	; 24
 156:	31 40       	sbci	r19, 0x01	; 1
 158:	2e 31       	cpi	r18, 0x1E	; 30
 15a:	31 05       	cpc	r19, r1
 15c:	08 f4       	brcc	.+2      	; 0x160 <main+0x112>
 15e:	45 c0       	rjmp	.+138    	; 0x1ea <main+0x19c>
			  {
				  lcd_clrscr();
				  lcd_puts("207mg/dL");
			  }
				else if (adc_value >= 310 && adc_value < 350)
 160:	9c 01       	movw	r18, r24
 162:	26 53       	subi	r18, 0x36	; 54
 164:	31 40       	sbci	r19, 0x01	; 1
 166:	28 32       	cpi	r18, 0x28	; 40
 168:	31 05       	cpc	r19, r1
 16a:	08 f4       	brcc	.+2      	; 0x16e <main+0x120>
 16c:	61 c0       	rjmp	.+194    	; 0x230 <main+0x1e2>
  				{
					  lcd_clrscr();
					  lcd_puts("238mg/dL");
  				}
				else if (adc_value >= 350 && adc_value < 400)
 16e:	8e 55       	subi	r24, 0x5E	; 94
 170:	91 40       	sbci	r25, 0x01	; 1
 172:	82 33       	cpi	r24, 0x32	; 50
 174:	91 05       	cpc	r25, r1
 176:	08 f4       	brcc	.+2      	; 0x17a <main+0x12c>
 178:	56 c0       	rjmp	.+172    	; 0x226 <main+0x1d8>
					  lcd_puts("280mg/dL");
  				}
				
  			else
  			{
				  lcd_clrscr();
 17a:	b2 d0       	rcall	.+356    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("Out of range");
 17c:	87 e0       	ldi	r24, 0x07	; 7
 17e:	91 e0       	ldi	r25, 0x01	; 1
 180:	c8 d0       	rcall	.+400    	; 0x312 <lcd_puts>
 182:	04 c0       	rjmp	.+8      	; 0x18c <main+0x13e>
				  lcd_clrscr();
				  lcd_puts("72mg/dL");
			  }
			  else if (adc_value >= 16 && adc_value < 32)
			  {
				  lcd_clrscr();
 184:	ad d0       	rcall	.+346    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("78mg/dL");
 186:	87 e9       	ldi	r24, 0x97	; 151
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	c3 d0       	rcall	.+390    	; 0x312 <lcd_puts>
				  lcd_clrscr();
				  lcd_puts("Out of range");
  			}
			return 0;
		}			  
 18c:	80 e0       	ldi	r24, 0x00	; 0
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	08 95       	ret
				  lcd_clrscr();
				  lcd_puts("67mg/dL");
			  }
			  else if (adc_value >= 4 && adc_value < 8)
			  {
				  lcd_clrscr();
 192:	a6 d0       	rcall	.+332    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("69mg/dL");
 194:	87 e8       	ldi	r24, 0x87	; 135
 196:	90 e0       	ldi	r25, 0x00	; 0
 198:	bc d0       	rcall	.+376    	; 0x312 <lcd_puts>
				  lcd_clrscr();
				  lcd_puts("Out of range");
  			}
			return 0;
		}			  
 19a:	80 e0       	ldi	r24, 0x00	; 0
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	08 95       	ret
				  lcd_clrscr();
				  lcd_puts("69mg/dL");
			  }
			  else if (adc_value >= 8 && adc_value < 16)
			  {
				  lcd_clrscr();
 1a0:	9f d0       	rcall	.+318    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("72mg/dL");
 1a2:	8f e8       	ldi	r24, 0x8F	; 143
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	b5 d0       	rcall	.+362    	; 0x312 <lcd_puts>
				  lcd_clrscr();
				  lcd_puts("Out of range");
  			}
			return 0;
		}			  
 1a8:	80 e0       	ldi	r24, 0x00	; 0
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	08 95       	ret

  			adc_value = ADCW;	//Store ADC result
			  
			  if (adc_value < 2)
			  {
				  lcd_clrscr();
 1ae:	98 d0       	rcall	.+304    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("65mg/dL");
 1b0:	87 e7       	ldi	r24, 0x77	; 119
 1b2:	90 e0       	ldi	r25, 0x00	; 0
 1b4:	ae d0       	rcall	.+348    	; 0x312 <lcd_puts>
 1b6:	ea cf       	rjmp	.-44     	; 0x18c <main+0x13e>
				  lcd_clrscr();
				  lcd_puts("78mg/dL");
			  }
			  else if (adc_value >= 32 && adc_value < 48)
			  {
				  lcd_clrscr();
 1b8:	93 d0       	rcall	.+294    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("82mg/dL");
 1ba:	8f e9       	ldi	r24, 0x9F	; 159
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	a9 d0       	rcall	.+338    	; 0x312 <lcd_puts>
 1c0:	e5 cf       	rjmp	.-54     	; 0x18c <main+0x13e>
				  lcd_clrscr();
				  lcd_puts("65mg/dL");
			  }
			  else if (adc_value >= 2 && adc_value < 4)
			  {
				  lcd_clrscr();
 1c2:	8e d0       	rcall	.+284    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("67mg/dL");
 1c4:	8f e7       	ldi	r24, 0x7F	; 127
 1c6:	90 e0       	ldi	r25, 0x00	; 0
 1c8:	a4 d0       	rcall	.+328    	; 0x312 <lcd_puts>
 1ca:	e0 cf       	rjmp	.-64     	; 0x18c <main+0x13e>
				  lcd_clrscr();
				  lcd_puts("82mg/dL");
			  }
			  else if (adc_value >= 48 && adc_value < 64)
			  {
				  lcd_clrscr();
 1cc:	89 d0       	rcall	.+274    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("87mg/dL");
 1ce:	87 ea       	ldi	r24, 0xA7	; 167
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	9f d0       	rcall	.+318    	; 0x312 <lcd_puts>
 1d4:	db cf       	rjmp	.-74     	; 0x18c <main+0x13e>
			  }
			  
			  else if (adc_value >= 64 && adc_value < 90)
			  {
				  lcd_clrscr();
 1d6:	84 d0       	rcall	.+264    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("93mg/dL");
 1d8:	8f ea       	ldi	r24, 0xAF	; 175
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	9a d0       	rcall	.+308    	; 0x312 <lcd_puts>
 1de:	d6 cf       	rjmp	.-84     	; 0x18c <main+0x13e>
			  }
			  
			  else if (adc_value >= 90 && adc_value < 128)
			  {
				  lcd_clrscr();
 1e0:	7f d0       	rcall	.+254    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("99mg/dL");
 1e2:	87 eb       	ldi	r24, 0xB7	; 183
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	95 d0       	rcall	.+298    	; 0x312 <lcd_puts>
 1e8:	d1 cf       	rjmp	.-94     	; 0x18c <main+0x13e>
				  lcd_clrscr();
				  lcd_puts("182mg/dL");
			  }
			  else if (adc_value >= 280 && adc_value < 310)
			  {
				  lcd_clrscr();
 1ea:	7a d0       	rcall	.+244    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("207mg/dL");
 1ec:	8c ee       	ldi	r24, 0xEC	; 236
 1ee:	90 e0       	ldi	r25, 0x00	; 0
 1f0:	90 d0       	rcall	.+288    	; 0x312 <lcd_puts>
 1f2:	cc cf       	rjmp	.-104    	; 0x18c <main+0x13e>
				  lcd_clrscr();
				  lcd_puts("99mg/dL");
			  }
			  else if (adc_value >= 128 && adc_value < 150)
			  {
				  lcd_clrscr();
 1f4:	75 d0       	rcall	.+234    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("107mg/dL");
 1f6:	8f eb       	ldi	r24, 0xBF	; 191
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	8b d0       	rcall	.+278    	; 0x312 <lcd_puts>
 1fc:	c7 cf       	rjmp	.-114    	; 0x18c <main+0x13e>
			  }
			  
			  else if (adc_value >= 150 && adc_value < 180)
			  {
				  lcd_clrscr();
 1fe:	70 d0       	rcall	.+224    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("118mg/dL");
 200:	88 ec       	ldi	r24, 0xC8	; 200
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	86 d0       	rcall	.+268    	; 0x312 <lcd_puts>
 206:	c2 cf       	rjmp	.-124    	; 0x18c <main+0x13e>
			  }
			  
			  else if (adc_value >= 180 && adc_value < 210)
			  {
				  lcd_clrscr();
 208:	6b d0       	rcall	.+214    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("135mg/dL");
 20a:	81 ed       	ldi	r24, 0xD1	; 209
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	81 d0       	rcall	.+258    	; 0x312 <lcd_puts>
 210:	bd cf       	rjmp	.-134    	; 0x18c <main+0x13e>
			  }
			  
			  else if (adc_value >= 210 && adc_value < 240)
			  {
				  lcd_clrscr();
 212:	66 d0       	rcall	.+204    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("163mg/dL");
 214:	8a ed       	ldi	r24, 0xDA	; 218
 216:	90 e0       	ldi	r25, 0x00	; 0
 218:	7c d0       	rcall	.+248    	; 0x312 <lcd_puts>
 21a:	b8 cf       	rjmp	.-144    	; 0x18c <main+0x13e>
			  }
			  else if (adc_value >= 240 && adc_value < 280)
			  {
				  lcd_clrscr();
 21c:	61 d0       	rcall	.+194    	; 0x2e0 <lcd_clrscr>
				  lcd_puts("182mg/dL");
 21e:	83 ee       	ldi	r24, 0xE3	; 227
 220:	90 e0       	ldi	r25, 0x00	; 0
 222:	77 d0       	rcall	.+238    	; 0x312 <lcd_puts>
 224:	b3 cf       	rjmp	.-154    	; 0x18c <main+0x13e>
					  lcd_clrscr();
					  lcd_puts("238mg/dL");
  				}
				else if (adc_value >= 350 && adc_value < 400)
  				{
					  lcd_clrscr();
 226:	5c d0       	rcall	.+184    	; 0x2e0 <lcd_clrscr>
					  lcd_puts("280mg/dL");
 228:	8e ef       	ldi	r24, 0xFE	; 254
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	72 d0       	rcall	.+228    	; 0x312 <lcd_puts>
 22e:	ae cf       	rjmp	.-164    	; 0x18c <main+0x13e>
				  lcd_clrscr();
				  lcd_puts("207mg/dL");
			  }
				else if (adc_value >= 310 && adc_value < 350)
  				{
					  lcd_clrscr();
 230:	57 d0       	rcall	.+174    	; 0x2e0 <lcd_clrscr>
					  lcd_puts("238mg/dL");
 232:	85 ef       	ldi	r24, 0xF5	; 245
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	6d d0       	rcall	.+218    	; 0x312 <lcd_puts>
 238:	a9 cf       	rjmp	.-174    	; 0x18c <main+0x13e>

0000023a <lcd_write>:
static void lcd_write(uint8_t data,uint8_t rs) 
{
    unsigned char dataBits ;


    if (rs) {   /* write data        (RS=1, RW=0) */
 23a:	66 23       	and	r22, r22
 23c:	c1 f4       	brne	.+48     	; 0x26e <lcd_write+0x34>
       lcd_rs_high();
    } else {    /* write instruction (RS=0, RW=0) */
       lcd_rs_low();
 23e:	94 98       	cbi	0x12, 4	; 18
    }
    lcd_rw_low();
 240:	95 98       	cbi	0x12, 5	; 18

    if ( ( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )
      && (LCD_DATA0_PIN == 0) && (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) )
    {
        /* configure data pins as output */
        DDR(LCD_DATA0_PORT) |= 0x0F;
 242:	91 b3       	in	r25, 0x11	; 17
 244:	9f 60       	ori	r25, 0x0F	; 15
 246:	91 bb       	out	0x11, r25	; 17

        /* output high nibble first */
        dataBits = LCD_DATA0_PORT & 0xF0;
 248:	92 b3       	in	r25, 0x12	; 18
 24a:	90 7f       	andi	r25, 0xF0	; 240
        LCD_DATA0_PORT = dataBits |((data>>4)&0x0F);
 24c:	28 2f       	mov	r18, r24
 24e:	22 95       	swap	r18
 250:	2f 70       	andi	r18, 0x0F	; 15
 252:	29 2b       	or	r18, r25
 254:	22 bb       	out	0x12, r18	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
 256:	96 9a       	sbi	0x12, 6	; 18
    lcd_e_delay();
 258:	00 c0       	rjmp	.+0      	; 0x25a <lcd_write+0x20>
    lcd_e_low();
 25a:	96 98       	cbi	0x12, 6	; 18
        dataBits = LCD_DATA0_PORT & 0xF0;
        LCD_DATA0_PORT = dataBits |((data>>4)&0x0F);
        lcd_e_toggle();

        /* output low nibble */
        LCD_DATA0_PORT = dataBits | (data&0x0F);
 25c:	8f 70       	andi	r24, 0x0F	; 15
 25e:	89 2b       	or	r24, r25
 260:	82 bb       	out	0x12, r24	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
 262:	96 9a       	sbi	0x12, 6	; 18
    lcd_e_delay();
 264:	00 c0       	rjmp	.+0      	; 0x266 <lcd_write+0x2c>
    lcd_e_low();
 266:	96 98       	cbi	0x12, 6	; 18
        /* output low nibble */
        LCD_DATA0_PORT = dataBits | (data&0x0F);
        lcd_e_toggle();

        /* all data pins high (inactive) */
        LCD_DATA0_PORT = dataBits | 0x0F;
 268:	9f 60       	ori	r25, 0x0F	; 15
 26a:	92 bb       	out	0x12, r25	; 18
        LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
        LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
        LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
        LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
    }
}
 26c:	08 95       	ret
{
    unsigned char dataBits ;


    if (rs) {   /* write data        (RS=1, RW=0) */
       lcd_rs_high();
 26e:	94 9a       	sbi	0x12, 4	; 18
 270:	e7 cf       	rjmp	.-50     	; 0x240 <lcd_write+0x6>

00000272 <lcd_read.clone.0>:
    
    
    if (rs)
        lcd_rs_high();                       /* RS=1: read data      */
    else
        lcd_rs_low();                        /* RS=0: read busy flag */
 272:	94 98       	cbi	0x12, 4	; 18
    lcd_rw_high();                           /* RW=1  read mode      */
 274:	95 9a       	sbi	0x12, 5	; 18
    
    if ( ( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )
      && ( LCD_DATA0_PIN == 0 )&& (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) )
    {
        DDR(LCD_DATA0_PORT) &= 0xF0;         /* configure data pins as input */
 276:	81 b3       	in	r24, 0x11	; 17
 278:	80 7f       	andi	r24, 0xF0	; 240
 27a:	81 bb       	out	0x11, r24	; 17
        
        lcd_e_high();
 27c:	96 9a       	sbi	0x12, 6	; 18
        lcd_e_delay();        
 27e:	00 c0       	rjmp	.+0      	; 0x280 <lcd_read.clone.0+0xe>
        data = PIN(LCD_DATA0_PORT) << 4;     /* read high nibble first */
 280:	90 b3       	in	r25, 0x10	; 16
        lcd_e_low();
 282:	96 98       	cbi	0x12, 6	; 18
        
        lcd_e_delay();                       /* Enable 500ns low       */
 284:	00 c0       	rjmp	.+0      	; 0x286 <lcd_read.clone.0+0x14>
        
        lcd_e_high();
 286:	96 9a       	sbi	0x12, 6	; 18
        lcd_e_delay();
 288:	00 c0       	rjmp	.+0      	; 0x28a <lcd_read.clone.0+0x18>
        data |= PIN(LCD_DATA0_PORT)&0x0F;    /* read low nibble        */
 28a:	80 b3       	in	r24, 0x10	; 16
    {
        DDR(LCD_DATA0_PORT) &= 0xF0;         /* configure data pins as input */
        
        lcd_e_high();
        lcd_e_delay();        
        data = PIN(LCD_DATA0_PORT) << 4;     /* read high nibble first */
 28c:	92 95       	swap	r25
 28e:	90 7f       	andi	r25, 0xF0	; 240
        
        lcd_e_delay();                       /* Enable 500ns low       */
        
        lcd_e_high();
        lcd_e_delay();
        data |= PIN(LCD_DATA0_PORT)&0x0F;    /* read low nibble        */
 290:	8f 70       	andi	r24, 0x0F	; 15
        lcd_e_low();
 292:	96 98       	cbi	0x12, 6	; 18
        if ( PIN(LCD_DATA2_PORT) & _BV(LCD_DATA2_PIN) ) data |= 0x04;
        if ( PIN(LCD_DATA3_PORT) & _BV(LCD_DATA3_PIN) ) data |= 0x08;        
        lcd_e_low();
    }
    return data;
}
 294:	89 2b       	or	r24, r25
 296:	08 95       	ret

00000298 <lcd_waitbusy>:

{
    register uint8_t c;
    
    /* wait until busy flag is cleared */
    while ( (c=lcd_read(0)) & (1<<LCD_BUSY)) {}
 298:	ec df       	rcall	.-40     	; 0x272 <lcd_read.clone.0>
 29a:	87 fd       	sbrc	r24, 7
 29c:	fd cf       	rjmp	.-6      	; 0x298 <lcd_waitbusy>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 29e:	88 e0       	ldi	r24, 0x08	; 8
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	01 97       	sbiw	r24, 0x01	; 1
 2a4:	f1 f7       	brne	.-4      	; 0x2a2 <lcd_waitbusy+0xa>
    
    /* the address counter is updated 4us after the busy flag is cleared */
    delay(2);

    /* now read the address counter */
    return (lcd_read(0));  // return address counter
 2a6:	e5 df       	rcall	.-54     	; 0x272 <lcd_read.clone.0>
    
}/* lcd_waitbusy */
 2a8:	08 95       	ret

000002aa <lcd_command>:
Send LCD controller instruction command
Input:   instruction to send to LCD controller, see HD44780 data sheet
Returns: none
*************************************************************************/
void lcd_command(uint8_t cmd)
{
 2aa:	1f 93       	push	r17
 2ac:	18 2f       	mov	r17, r24
    lcd_waitbusy();
 2ae:	f4 df       	rcall	.-24     	; 0x298 <lcd_waitbusy>
    lcd_write(cmd,0);
 2b0:	81 2f       	mov	r24, r17
 2b2:	60 e0       	ldi	r22, 0x00	; 0
 2b4:	c2 df       	rcall	.-124    	; 0x23a <lcd_write>
}
 2b6:	1f 91       	pop	r17
 2b8:	08 95       	ret

000002ba <lcd_data>:
Send data byte to LCD controller 
Input:   data to send to LCD controller, see HD44780 data sheet
Returns: none
*************************************************************************/
void lcd_data(uint8_t data)
{
 2ba:	1f 93       	push	r17
 2bc:	18 2f       	mov	r17, r24
    lcd_waitbusy();
 2be:	ec df       	rcall	.-40     	; 0x298 <lcd_waitbusy>
    lcd_write(data,1);
 2c0:	81 2f       	mov	r24, r17
 2c2:	61 e0       	ldi	r22, 0x01	; 1
 2c4:	ba df       	rcall	.-140    	; 0x23a <lcd_write>
}
 2c6:	1f 91       	pop	r17
 2c8:	08 95       	ret

000002ca <lcd_gotoxy>:
{
#if LCD_LINES==1
    lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
#endif
#if LCD_LINES==2
    if ( y==0 ) 
 2ca:	66 23       	and	r22, r22
 2cc:	19 f0       	breq	.+6      	; 0x2d4 <lcd_gotoxy+0xa>
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
    else
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE2+x);
 2ce:	80 54       	subi	r24, 0x40	; 64
 2d0:	ec df       	rcall	.-40     	; 0x2aa <lcd_command>
 2d2:	08 95       	ret
#if LCD_LINES==1
    lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
#endif
#if LCD_LINES==2
    if ( y==0 ) 
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
 2d4:	80 58       	subi	r24, 0x80	; 128
 2d6:	e9 df       	rcall	.-46     	; 0x2aa <lcd_command>
 2d8:	08 95       	ret

000002da <lcd_getxy>:

/*************************************************************************
*************************************************************************/
int lcd_getxy(void)
{
    return lcd_waitbusy();
 2da:	de df       	rcall	.-68     	; 0x298 <lcd_waitbusy>
}
 2dc:	90 e0       	ldi	r25, 0x00	; 0
 2de:	08 95       	ret

000002e0 <lcd_clrscr>:
/*************************************************************************
Clear display and set cursor to home position
*************************************************************************/
void lcd_clrscr(void)
{
    lcd_command(1<<LCD_CLR);
 2e0:	81 e0       	ldi	r24, 0x01	; 1
 2e2:	e3 df       	rcall	.-58     	; 0x2aa <lcd_command>
}
 2e4:	08 95       	ret

000002e6 <lcd_home>:
/*************************************************************************
Set cursor to home position
*************************************************************************/
void lcd_home(void)
{
    lcd_command(1<<LCD_HOME);
 2e6:	82 e0       	ldi	r24, 0x02	; 2
 2e8:	e0 df       	rcall	.-64     	; 0x2aa <lcd_command>
}
 2ea:	08 95       	ret

000002ec <lcd_putc>:
Display character at current cursor position 
Input:    character to be displayed                                       
Returns:  none
*************************************************************************/
void lcd_putc(char c)
{
 2ec:	1f 93       	push	r17
 2ee:	18 2f       	mov	r17, r24
    uint8_t pos;


    pos = lcd_waitbusy();   // read busy-flag and address counter
 2f0:	d3 df       	rcall	.-90     	; 0x298 <lcd_waitbusy>
    if (c=='\n')
 2f2:	1a 30       	cpi	r17, 0x0A	; 10
 2f4:	29 f0       	breq	.+10     	; 0x300 <lcd_putc+0x14>
            lcd_write((1<<LCD_DDRAM)+LCD_START_LINE1,0);
        }
#endif
        lcd_waitbusy();
#endif
        lcd_write(c, 1);
 2f6:	81 2f       	mov	r24, r17
 2f8:	61 e0       	ldi	r22, 0x01	; 1
 2fa:	9f df       	rcall	.-194    	; 0x23a <lcd_write>
    }

}/* lcd_putc */
 2fc:	1f 91       	pop	r17
 2fe:	08 95       	ret

#if LCD_LINES==1
    addressCounter = 0;
#endif
#if LCD_LINES==2
    if ( pos < (LCD_START_LINE2) )
 300:	80 34       	cpi	r24, 0x40	; 64
 302:	20 f0       	brcs	.+8      	; 0x30c <lcd_putc+0x20>
 304:	80 e8       	ldi	r24, 0x80	; 128
        addressCounter = LCD_START_LINE4;
    else 
        addressCounter = LCD_START_LINE1;
#endif
#endif
    lcd_command((1<<LCD_DDRAM)+addressCounter);
 306:	d1 df       	rcall	.-94     	; 0x2aa <lcd_command>
        lcd_waitbusy();
#endif
        lcd_write(c, 1);
    }

}/* lcd_putc */
 308:	1f 91       	pop	r17
 30a:	08 95       	ret

#if LCD_LINES==1
    addressCounter = 0;
#endif
#if LCD_LINES==2
    if ( pos < (LCD_START_LINE2) )
 30c:	80 ec       	ldi	r24, 0xC0	; 192
        addressCounter = LCD_START_LINE4;
    else 
        addressCounter = LCD_START_LINE1;
#endif
#endif
    lcd_command((1<<LCD_DDRAM)+addressCounter);
 30e:	cd df       	rcall	.-102    	; 0x2aa <lcd_command>
 310:	fb cf       	rjmp	.-10     	; 0x308 <lcd_putc+0x1c>

00000312 <lcd_puts>:
Input:    string to be displayed
Returns:  none
*************************************************************************/
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
 312:	cf 93       	push	r28
 314:	df 93       	push	r29
 316:	ec 01       	movw	r28, r24
    register char c;

    while ( (c = *s++) ) {
 318:	88 81       	ld	r24, Y
 31a:	88 23       	and	r24, r24
 31c:	29 f0       	breq	.+10     	; 0x328 <lcd_puts+0x16>
 31e:	21 96       	adiw	r28, 0x01	; 1
        lcd_putc(c);
 320:	e5 df       	rcall	.-54     	; 0x2ec <lcd_putc>
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = *s++) ) {
 322:	89 91       	ld	r24, Y+
 324:	88 23       	and	r24, r24
 326:	e1 f7       	brne	.-8      	; 0x320 <lcd_puts+0xe>
        lcd_putc(c);
    }

}/* lcd_puts */
 328:	df 91       	pop	r29
 32a:	cf 91       	pop	r28
 32c:	08 95       	ret

0000032e <lcd_puts_p>:
Input:     string from program memory be be displayed                                        
Returns:   none
*************************************************************************/
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
 32e:	cf 93       	push	r28
 330:	df 93       	push	r29
 332:	ec 01       	movw	r28, r24
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
 334:	fc 01       	movw	r30, r24
 336:	84 91       	lpm	r24, Z+
 338:	88 23       	and	r24, r24
 33a:	39 f0       	breq	.+14     	; 0x34a <lcd_puts_p+0x1c>
 33c:	21 96       	adiw	r28, 0x01	; 1
        lcd_putc(c);
 33e:	d6 df       	rcall	.-84     	; 0x2ec <lcd_putc>
 340:	fe 01       	movw	r30, r28
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
 342:	21 96       	adiw	r28, 0x01	; 1
 344:	84 91       	lpm	r24, Z+
 346:	88 23       	and	r24, r24
 348:	d1 f7       	brne	.-12     	; 0x33e <lcd_puts_p+0x10>
        lcd_putc(c);
    }

}/* lcd_puts_p */
 34a:	df 91       	pop	r29
 34c:	cf 91       	pop	r28
 34e:	08 95       	ret

00000350 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 350:	1f 93       	push	r17
 352:	18 2f       	mov	r17, r24
      && ( &LCD_RS_PORT == &LCD_DATA0_PORT) && ( &LCD_RW_PORT == &LCD_DATA0_PORT) && (&LCD_E_PORT == &LCD_DATA0_PORT)
      && (LCD_DATA0_PIN == 0 ) && (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) 
      && (LCD_RS_PIN == 4 ) && (LCD_RW_PIN == 5) && (LCD_E_PIN == 6 ) )
    {
        /* configure all port bits as output (all LCD lines on same port) */
        DDR(LCD_DATA0_PORT) |= 0x7F;
 354:	81 b3       	in	r24, 0x11	; 17
 356:	8f 67       	ori	r24, 0x7F	; 127
 358:	81 bb       	out	0x11, r24	; 17
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 35a:	e0 e0       	ldi	r30, 0x00	; 0
 35c:	fa ef       	ldi	r31, 0xFA	; 250
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	f1 f7       	brne	.-4      	; 0x35e <lcd_init+0xe>
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    }
    delay(16000);        /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
 362:	91 9a       	sbi	0x12, 1	; 18
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
 364:	90 9a       	sbi	0x12, 0	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
 366:	96 9a       	sbi	0x12, 6	; 18
    lcd_e_delay();
 368:	00 c0       	rjmp	.+0      	; 0x36a <lcd_init+0x1a>
    lcd_e_low();
 36a:	96 98       	cbi	0x12, 6	; 18
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 36c:	e0 e0       	ldi	r30, 0x00	; 0
 36e:	fe e4       	ldi	r31, 0x4E	; 78
 370:	31 97       	sbiw	r30, 0x01	; 1
 372:	f1 f7       	brne	.-4      	; 0x370 <lcd_init+0x20>

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
 374:	96 9a       	sbi	0x12, 6	; 18
    lcd_e_delay();
 376:	00 c0       	rjmp	.+0      	; 0x378 <lcd_init+0x28>
    lcd_e_low();
 378:	96 98       	cbi	0x12, 6	; 18
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 37a:	20 e0       	ldi	r18, 0x00	; 0
 37c:	31 e0       	ldi	r19, 0x01	; 1
 37e:	f9 01       	movw	r30, r18
 380:	31 97       	sbiw	r30, 0x01	; 1
 382:	f1 f7       	brne	.-4      	; 0x380 <lcd_init+0x30>

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
 384:	96 9a       	sbi	0x12, 6	; 18
    lcd_e_delay();
 386:	00 c0       	rjmp	.+0      	; 0x388 <lcd_init+0x38>
    lcd_e_low();
 388:	96 98       	cbi	0x12, 6	; 18
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 38a:	f9 01       	movw	r30, r18
 38c:	31 97       	sbiw	r30, 0x01	; 1
 38e:	f1 f7       	brne	.-4      	; 0x38c <lcd_init+0x3c>
    /* repeat last command a third time */
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
 390:	90 98       	cbi	0x12, 0	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
 392:	96 9a       	sbi	0x12, 6	; 18
    lcd_e_delay();
 394:	00 c0       	rjmp	.+0      	; 0x396 <lcd_init+0x46>
    lcd_e_low();
 396:	96 98       	cbi	0x12, 6	; 18
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 398:	f9 01       	movw	r30, r18
 39a:	31 97       	sbiw	r30, 0x01	; 1
 39c:	f1 f7       	brne	.-4      	; 0x39a <lcd_init+0x4a>
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
	lcd_command(KS0073_4LINES_MODE);
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
 39e:	88 e2       	ldi	r24, 0x28	; 40
 3a0:	84 df       	rcall	.-248    	; 0x2aa <lcd_command>
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
 3a2:	88 e0       	ldi	r24, 0x08	; 8
 3a4:	82 df       	rcall	.-252    	; 0x2aa <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
 3a6:	9c df       	rcall	.-200    	; 0x2e0 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 3a8:	86 e0       	ldi	r24, 0x06	; 6
 3aa:	7f df       	rcall	.-258    	; 0x2aa <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
 3ac:	81 2f       	mov	r24, r17
 3ae:	7d df       	rcall	.-262    	; 0x2aa <lcd_command>

}/* lcd_init */
 3b0:	1f 91       	pop	r17
 3b2:	08 95       	ret

000003b4 <_exit>:
 3b4:	f8 94       	cli

000003b6 <__stop_program>:
 3b6:	ff cf       	rjmp	.-2      	; 0x3b6 <__stop_program>
